//! Errors that can be returned by the library
use actix::MailboxError;
use std::io;
use std::path::{Path, PathBuf};

/// Convience wrapper for `Result` returned by fallible functions in the library
pub type Result<T> = std::result::Result<T, Error>;

/// Enum wrapping all possible errors that can be generated by the library
#[derive(Debug, thiserror::Error)]
pub enum Error {
    /// Wraps actix's `MailboxError` error
    #[error("internal gWasm API error: {0}")]
    MailboxError(#[from] MailboxError),

    /// Wraps libstd's `std::io::Error` error
    #[error("gWasm API error: {0}")]
    IOError(#[from] io::Error),

    /// Wraps libstd's `std::io::Error` error providing file context
    #[error("gWasm API error: {1}: {0}")]
    FileError(io::Error, PathBuf),

    /// Wraps Golem's `actix_wamp::Error` error
    #[error("internal Golem error: {0}")]
    WampError(actix_wamp::Error),

    /// Wraps Golem RPC's `golem_rpc_api::Error` error
    #[error("internal Golem error: {0}")]
    GolemRPCError(golem_rpc_api::Error),

    /// Wraps `chrono::ParseError` error
    #[error("error parsing Timeout value: {0}")]
    ChronoError(#[from] chrono::ParseError),

    /// Received Ctrl-C interrupt
    #[error("received Ctrl-C interrupt")]
    KeyboardInterrupt,

    /// Error generated when trying to create a zero [`Timeout`](../timeout/struct.Timeout.html)
    /// value for a Golem Task
    #[error("zero timeout \"00:00:00\" is forbidden")]
    ZeroTimeoutError,

    /// Error when no TaskInfo is received when polling for task progress
    /// in [`poll_task_progress`](../golem/fn.poll_task_progress.html)
    #[error("empty TaskInfo received from Golem")]
    EmptyTaskInfo,

    /// Error when no progress can be extracted from TaskInfo
    #[error("empty progress in TaskInfo")]
    EmptyProgress,

    /// Error when gWasm task was aborted externally
    #[error("task aborted externally")]
    TaskAborted,

    /// Error when gWasm task timed out
    #[error("task timed out")]
    TaskTimedOut,
}

impl From<actix_wamp::Error> for Error {
    fn from(err: actix_wamp::Error) -> Self {
        Self::WampError(err)
    }
}

impl From<golem_rpc_api::Error> for Error {
    fn from(err: golem_rpc_api::Error) -> Self {
        Self::GolemRPCError(err)
    }
}

pub(crate) trait FileContext<T, P> {
    fn file_context(self, path: P) -> Result<T>;
}

impl<T, P: AsRef<Path>> FileContext<T, P> for io::Result<T> {
    fn file_context(self, path: P) -> Result<T> {
        self.map_err(|e| Error::FileError(e, path.as_ref().to_owned()))
    }
}
